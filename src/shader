// This is an example of a shader that might be used
// The actual shader code is produced in runtime based
// on `group_size` and `kernel` values

#version 430 core

layout(local_size_x = 2, local_size_y = 2) in;
layout(binding = 0, rgba8) restrict readonly uniform imageBuffer input_image;
layout(binding = 1, rgba8) restrict writeonly uniform imageBuffer output_image;
layout(std140, binding = 2) readonly uniform ImageData {
    int offset;
    int width;
    int height;
};
const int KERNEL_SIZE = 25;
const float[KERNEL_SIZE] KERNEL = float[KERNEL_SIZE](
0.0011098814, 0.002277329, 0.0043896665, 0.00794866, 0.013521125, 
0.021606697, 0.03243549, 0.045741376, 0.06059748, 0.075414784, 
0.08816881, 0.09683449, 0.09990835, 0.09683449, 0.08816881, 
0.075414784, 0.06059748, 0.045741376, 0.03243549, 0.021606697, 
0.013521125, 0.00794866, 0.0043896665, 0.002277329, 0.0011098814);

uniform ivec2 direction;

vec4 fetch_pixel(ivec2 pos) {
    int x = pos.x;
    int y = pos.y * width;
    return imageLoad(input_image, offset + x + y);
}

void write_pixel(ivec2 pos, vec4 pixel) {
    int x = pos.x;
    int y = pos.y * width;
    imageStore(output_image, offset + x + y, pixel);
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

    if (pos.x >= width || pos.y >= height) return;

    vec4 sum = vec4(0.0);
    for (int i = 0; i < KERNEL_SIZE; ++i)
    {
        ivec2 npos = pos + direction * (i - KERNEL_SIZE / 2);
        if (npos.x < 0) npos.x = 0;
        if (npos.y < 0) npos.y = 0;
        if (npos.x >= width) npos.x = width - 1;
        if (npos.y >= height) npos.y = height - 1;
        sum += KERNEL[i] * fetch_pixel(npos);
    }
    write_pixel(pos, sum);
}